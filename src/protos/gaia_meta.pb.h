// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gaia_meta.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gaia_5fmeta_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gaia_5fmeta_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gaia_5fmeta_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gaia_5fmeta_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gaia_5fmeta_2eproto;
namespace com {
namespace gaia {
namespace core {
class CallRequest;
struct CallRequestDefaultTypeInternal;
extern CallRequestDefaultTypeInternal _CallRequest_default_instance_;
class CallResponse;
struct CallResponseDefaultTypeInternal;
extern CallResponseDefaultTypeInternal _CallResponse_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class Endpoint;
struct EndpointDefaultTypeInternal;
extern EndpointDefaultTypeInternal _Endpoint_default_instance_;
class Endpoints;
struct EndpointsDefaultTypeInternal;
extern EndpointsDefaultTypeInternal _Endpoints_default_instance_;
class Job;
struct JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
class RepeatedData;
struct RepeatedDataDefaultTypeInternal;
extern RepeatedDataDefaultTypeInternal _RepeatedData_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class ReturnStatus;
struct ReturnStatusDefaultTypeInternal;
extern ReturnStatusDefaultTypeInternal _ReturnStatus_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
}  // namespace core
}  // namespace gaia
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::gaia::core::CallRequest* Arena::CreateMaybeMessage<::com::gaia::core::CallRequest>(Arena*);
template<> ::com::gaia::core::CallResponse* Arena::CreateMaybeMessage<::com::gaia::core::CallResponse>(Arena*);
template<> ::com::gaia::core::Data* Arena::CreateMaybeMessage<::com::gaia::core::Data>(Arena*);
template<> ::com::gaia::core::Endpoint* Arena::CreateMaybeMessage<::com::gaia::core::Endpoint>(Arena*);
template<> ::com::gaia::core::Endpoints* Arena::CreateMaybeMessage<::com::gaia::core::Endpoints>(Arena*);
template<> ::com::gaia::core::Job* Arena::CreateMaybeMessage<::com::gaia::core::Job>(Arena*);
template<> ::com::gaia::core::RepeatedData* Arena::CreateMaybeMessage<::com::gaia::core::RepeatedData>(Arena*);
template<> ::com::gaia::core::Result* Arena::CreateMaybeMessage<::com::gaia::core::Result>(Arena*);
template<> ::com::gaia::core::ReturnStatus* Arena::CreateMaybeMessage<::com::gaia::core::ReturnStatus>(Arena*);
template<> ::com::gaia::core::Task* Arena::CreateMaybeMessage<::com::gaia::core::Task>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace gaia {
namespace core {

// ===================================================================

class Endpoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.Endpoint) */ {
 public:
  inline Endpoint() : Endpoint(nullptr) {}
  ~Endpoint() override;
  explicit PROTOBUF_CONSTEXPR Endpoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Endpoint(const Endpoint& from);
  Endpoint(Endpoint&& from) noexcept
    : Endpoint() {
    *this = ::std::move(from);
  }

  inline Endpoint& operator=(const Endpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Endpoint& operator=(Endpoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Endpoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Endpoint* internal_default_instance() {
    return reinterpret_cast<const Endpoint*>(
               &_Endpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Endpoint& a, Endpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Endpoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Endpoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Endpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Endpoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Endpoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Endpoint& from) {
    Endpoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Endpoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.Endpoint";
  }
  protected:
  explicit Endpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kHostnameFieldNumber = 3,
    kPortFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string hostname = 3;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.gaia.core.Endpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    int32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// -------------------------------------------------------------------

class Endpoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.Endpoints) */ {
 public:
  inline Endpoints() : Endpoints(nullptr) {}
  ~Endpoints() override;
  explicit PROTOBUF_CONSTEXPR Endpoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Endpoints(const Endpoints& from);
  Endpoints(Endpoints&& from) noexcept
    : Endpoints() {
    *this = ::std::move(from);
  }

  inline Endpoints& operator=(const Endpoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Endpoints& operator=(Endpoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Endpoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const Endpoints* internal_default_instance() {
    return reinterpret_cast<const Endpoints*>(
               &_Endpoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Endpoints& a, Endpoints& b) {
    a.Swap(&b);
  }
  inline void Swap(Endpoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Endpoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Endpoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Endpoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Endpoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Endpoints& from) {
    Endpoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Endpoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.Endpoints";
  }
  protected:
  explicit Endpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 1,
  };
  // repeated .com.gaia.core.Endpoint endpoints = 1;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  ::com::gaia::core::Endpoint* mutable_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Endpoint >*
      mutable_endpoints();
  private:
  const ::com::gaia::core::Endpoint& _internal_endpoints(int index) const;
  ::com::gaia::core::Endpoint* _internal_add_endpoints();
  public:
  const ::com::gaia::core::Endpoint& endpoints(int index) const;
  ::com::gaia::core::Endpoint* add_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Endpoint >&
      endpoints() const;

  // @@protoc_insertion_point(class_scope:com.gaia.core.Endpoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Endpoint > endpoints_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// -------------------------------------------------------------------

class Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  explicit PROTOBUF_CONSTEXPR Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Data& from) {
    Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostLanguageFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDataFieldNumber = 4,
    kIsNullFieldNumber = 1,
  };
  // string hostLanguage = 2;
  void clear_hostlanguage();
  const std::string& hostlanguage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostlanguage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostlanguage();
  PROTOBUF_NODISCARD std::string* release_hostlanguage();
  void set_allocated_hostlanguage(std::string* hostlanguage);
  private:
  const std::string& _internal_hostlanguage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostlanguage(const std::string& value);
  std::string* _internal_mutable_hostlanguage();
  public:

  // string type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bool isNull = 1;
  void clear_isnull();
  bool isnull() const;
  void set_isnull(bool value);
  private:
  bool _internal_isnull() const;
  void _internal_set_isnull(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.gaia.core.Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostlanguage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    bool isnull_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// -------------------------------------------------------------------

class RepeatedData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.RepeatedData) */ {
 public:
  inline RepeatedData() : RepeatedData(nullptr) {}
  ~RepeatedData() override;
  explicit PROTOBUF_CONSTEXPR RepeatedData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepeatedData(const RepeatedData& from);
  RepeatedData(RepeatedData&& from) noexcept
    : RepeatedData() {
    *this = ::std::move(from);
  }

  inline RepeatedData& operator=(const RepeatedData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepeatedData& operator=(RepeatedData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepeatedData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepeatedData* internal_default_instance() {
    return reinterpret_cast<const RepeatedData*>(
               &_RepeatedData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RepeatedData& a, RepeatedData& b) {
    a.Swap(&b);
  }
  inline void Swap(RepeatedData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepeatedData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepeatedData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepeatedData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RepeatedData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RepeatedData& from) {
    RepeatedData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepeatedData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.RepeatedData";
  }
  protected:
  explicit RepeatedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatalistFieldNumber = 1,
  };
  // repeated .com.gaia.core.Data datalist = 1;
  int datalist_size() const;
  private:
  int _internal_datalist_size() const;
  public:
  void clear_datalist();
  ::com::gaia::core::Data* mutable_datalist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Data >*
      mutable_datalist();
  private:
  const ::com::gaia::core::Data& _internal_datalist(int index) const;
  ::com::gaia::core::Data* _internal_add_datalist();
  public:
  const ::com::gaia::core::Data& datalist(int index) const;
  ::com::gaia::core::Data* add_datalist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Data >&
      datalist() const;

  // @@protoc_insertion_point(class_scope:com.gaia.core.RepeatedData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Data > datalist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// -------------------------------------------------------------------

class CallRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.CallRequest) */ {
 public:
  inline CallRequest() : CallRequest(nullptr) {}
  ~CallRequest() override;
  explicit PROTOBUF_CONSTEXPR CallRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallRequest(const CallRequest& from);
  CallRequest(CallRequest&& from) noexcept
    : CallRequest() {
    *this = ::std::move(from);
  }

  inline CallRequest& operator=(const CallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallRequest& operator=(CallRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallRequest* internal_default_instance() {
    return reinterpret_cast<const CallRequest*>(
               &_CallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CallRequest& a, CallRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CallRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallRequest& from) {
    CallRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.CallRequest";
  }
  protected:
  explicit CallRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 3,
    kParamFieldNumber = 4,
    kTimeoutFieldNumber = 2,
    kIsAsyncFieldNumber = 1,
  };
  // string command = 3;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // .com.gaia.core.Data param = 4;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::com::gaia::core::Data& param() const;
  PROTOBUF_NODISCARD ::com::gaia::core::Data* release_param();
  ::com::gaia::core::Data* mutable_param();
  void set_allocated_param(::com::gaia::core::Data* param);
  private:
  const ::com::gaia::core::Data& _internal_param() const;
  ::com::gaia::core::Data* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::com::gaia::core::Data* param);
  ::com::gaia::core::Data* unsafe_arena_release_param();

  // int64 timeout = 2;
  void clear_timeout();
  int64_t timeout() const;
  void set_timeout(int64_t value);
  private:
  int64_t _internal_timeout() const;
  void _internal_set_timeout(int64_t value);
  public:

  // bool isAsync = 1;
  void clear_isasync();
  bool isasync() const;
  void set_isasync(bool value);
  private:
  bool _internal_isasync() const;
  void _internal_set_isasync(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.gaia.core.CallRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
    ::com::gaia::core::Data* param_;
    int64_t timeout_;
    bool isasync_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// -------------------------------------------------------------------

class CallResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.CallResponse) */ {
 public:
  inline CallResponse() : CallResponse(nullptr) {}
  ~CallResponse() override;
  explicit PROTOBUF_CONSTEXPR CallResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallResponse(const CallResponse& from);
  CallResponse(CallResponse&& from) noexcept
    : CallResponse() {
    *this = ::std::move(from);
  }

  inline CallResponse& operator=(const CallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallResponse& operator=(CallResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallResponse* internal_default_instance() {
    return reinterpret_cast<const CallResponse*>(
               &_CallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CallResponse& a, CallResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CallResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallResponse& from) {
    CallResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.CallResponse";
  }
  protected:
  explicit CallResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReturnStatusFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // .com.gaia.core.ReturnStatus returnStatus = 1;
  bool has_returnstatus() const;
  private:
  bool _internal_has_returnstatus() const;
  public:
  void clear_returnstatus();
  const ::com::gaia::core::ReturnStatus& returnstatus() const;
  PROTOBUF_NODISCARD ::com::gaia::core::ReturnStatus* release_returnstatus();
  ::com::gaia::core::ReturnStatus* mutable_returnstatus();
  void set_allocated_returnstatus(::com::gaia::core::ReturnStatus* returnstatus);
  private:
  const ::com::gaia::core::ReturnStatus& _internal_returnstatus() const;
  ::com::gaia::core::ReturnStatus* _internal_mutable_returnstatus();
  public:
  void unsafe_arena_set_allocated_returnstatus(
      ::com::gaia::core::ReturnStatus* returnstatus);
  ::com::gaia::core::ReturnStatus* unsafe_arena_release_returnstatus();

  // .com.gaia.core.Data result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::com::gaia::core::Data& result() const;
  PROTOBUF_NODISCARD ::com::gaia::core::Data* release_result();
  ::com::gaia::core::Data* mutable_result();
  void set_allocated_result(::com::gaia::core::Data* result);
  private:
  const ::com::gaia::core::Data& _internal_result() const;
  ::com::gaia::core::Data* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::com::gaia::core::Data* result);
  ::com::gaia::core::Data* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:com.gaia.core.CallResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::com::gaia::core::ReturnStatus* returnstatus_;
    ::com::gaia::core::Data* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// -------------------------------------------------------------------

class Job final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.Job) */ {
 public:
  inline Job() : Job(nullptr) {}
  ~Job() override;
  explicit PROTOBUF_CONSTEXPR Job(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Job(const Job& from);
  Job(Job&& from) noexcept
    : Job() {
    *this = ::std::move(from);
  }

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job& operator=(Job&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Job& a, Job& b) {
    a.Swap(&b);
  }
  inline void Swap(Job* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Job& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Job& from) {
    Job::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.Job";
  }
  protected:
  explicit Job(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string jobId = 1;
  void clear_jobid();
  const std::string& jobid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jobid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jobid();
  PROTOBUF_NODISCARD std::string* release_jobid();
  void set_allocated_jobid(std::string* jobid);
  private:
  const std::string& _internal_jobid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jobid(const std::string& value);
  std::string* _internal_mutable_jobid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:com.gaia.core.Job)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jobid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit PROTOBUF_CONSTEXPR Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Task& from) {
    Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobFieldNumber = 1,
    kTaskIdFieldNumber = 2,
    kTableIdFieldNumber = 3,
  };
  // .com.gaia.core.Job job = 1;
  bool has_job() const;
  private:
  bool _internal_has_job() const;
  public:
  void clear_job();
  const ::com::gaia::core::Job& job() const;
  PROTOBUF_NODISCARD ::com::gaia::core::Job* release_job();
  ::com::gaia::core::Job* mutable_job();
  void set_allocated_job(::com::gaia::core::Job* job);
  private:
  const ::com::gaia::core::Job& _internal_job() const;
  ::com::gaia::core::Job* _internal_mutable_job();
  public:
  void unsafe_arena_set_allocated_job(
      ::com::gaia::core::Job* job);
  ::com::gaia::core::Job* unsafe_arena_release_job();

  // int64 taskId = 2;
  void clear_taskid();
  int64_t taskid() const;
  void set_taskid(int64_t value);
  private:
  int64_t _internal_taskid() const;
  void _internal_set_taskid(int64_t value);
  public:

  // int64 tableId = 3;
  void clear_tableid();
  int64_t tableid() const;
  void set_tableid(int64_t value);
  private:
  int64_t _internal_tableid() const;
  void _internal_set_tableid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.gaia.core.Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::com::gaia::core::Job* job_;
    int64_t taskid_;
    int64_t tableid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// -------------------------------------------------------------------

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  explicit PROTOBUF_CONSTEXPR Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Result& from) {
    Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 1,
    kResultIdFieldNumber = 2,
  };
  // .com.gaia.core.Task task = 1;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::com::gaia::core::Task& task() const;
  PROTOBUF_NODISCARD ::com::gaia::core::Task* release_task();
  ::com::gaia::core::Task* mutable_task();
  void set_allocated_task(::com::gaia::core::Task* task);
  private:
  const ::com::gaia::core::Task& _internal_task() const;
  ::com::gaia::core::Task* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::com::gaia::core::Task* task);
  ::com::gaia::core::Task* unsafe_arena_release_task();

  // int64 resultId = 2;
  void clear_resultid();
  int64_t resultid() const;
  void set_resultid(int64_t value);
  private:
  int64_t _internal_resultid() const;
  void _internal_set_resultid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.gaia.core.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::com::gaia::core::Task* task_;
    int64_t resultid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// -------------------------------------------------------------------

class ReturnStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.gaia.core.ReturnStatus) */ {
 public:
  inline ReturnStatus() : ReturnStatus(nullptr) {}
  ~ReturnStatus() override;
  explicit PROTOBUF_CONSTEXPR ReturnStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReturnStatus(const ReturnStatus& from);
  ReturnStatus(ReturnStatus&& from) noexcept
    : ReturnStatus() {
    *this = ::std::move(from);
  }

  inline ReturnStatus& operator=(const ReturnStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReturnStatus& operator=(ReturnStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReturnStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReturnStatus* internal_default_instance() {
    return reinterpret_cast<const ReturnStatus*>(
               &_ReturnStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReturnStatus& a, ReturnStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ReturnStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReturnStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReturnStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReturnStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReturnStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReturnStatus& from) {
    ReturnStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReturnStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.gaia.core.ReturnStatus";
  }
  protected:
  explicit ReturnStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:com.gaia.core.ReturnStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gaia_5fmeta_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Endpoint

// string ip = 1;
inline void Endpoint::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& Endpoint::ip() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Endpoint.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Endpoint::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.gaia.core.Endpoint.ip)
}
inline std::string* Endpoint::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Endpoint.ip)
  return _s;
}
inline const std::string& Endpoint::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void Endpoint::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Endpoint::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Endpoint::release_ip() {
  // @@protoc_insertion_point(field_release:com.gaia.core.Endpoint.ip)
  return _impl_.ip_.Release();
}
inline void Endpoint::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.Endpoint.ip)
}

// int32 port = 2;
inline void Endpoint::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t Endpoint::_internal_port() const {
  return _impl_.port_;
}
inline int32_t Endpoint::port() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Endpoint.port)
  return _internal_port();
}
inline void Endpoint::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void Endpoint::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:com.gaia.core.Endpoint.port)
}

// string hostname = 3;
inline void Endpoint::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& Endpoint::hostname() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Endpoint.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Endpoint::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.gaia.core.Endpoint.hostname)
}
inline std::string* Endpoint::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Endpoint.hostname)
  return _s;
}
inline const std::string& Endpoint::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void Endpoint::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* Endpoint::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* Endpoint::release_hostname() {
  // @@protoc_insertion_point(field_release:com.gaia.core.Endpoint.hostname)
  return _impl_.hostname_.Release();
}
inline void Endpoint::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.Endpoint.hostname)
}

// -------------------------------------------------------------------

// Endpoints

// repeated .com.gaia.core.Endpoint endpoints = 1;
inline int Endpoints::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int Endpoints::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void Endpoints::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline ::com::gaia::core::Endpoint* Endpoints::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Endpoints.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Endpoint >*
Endpoints::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:com.gaia.core.Endpoints.endpoints)
  return &_impl_.endpoints_;
}
inline const ::com::gaia::core::Endpoint& Endpoints::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const ::com::gaia::core::Endpoint& Endpoints::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Endpoints.endpoints)
  return _internal_endpoints(index);
}
inline ::com::gaia::core::Endpoint* Endpoints::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline ::com::gaia::core::Endpoint* Endpoints::add_endpoints() {
  ::com::gaia::core::Endpoint* _add = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add:com.gaia.core.Endpoints.endpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Endpoint >&
Endpoints::endpoints() const {
  // @@protoc_insertion_point(field_list:com.gaia.core.Endpoints.endpoints)
  return _impl_.endpoints_;
}

// -------------------------------------------------------------------

// Data

// bool isNull = 1;
inline void Data::clear_isnull() {
  _impl_.isnull_ = false;
}
inline bool Data::_internal_isnull() const {
  return _impl_.isnull_;
}
inline bool Data::isnull() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Data.isNull)
  return _internal_isnull();
}
inline void Data::_internal_set_isnull(bool value) {
  
  _impl_.isnull_ = value;
}
inline void Data::set_isnull(bool value) {
  _internal_set_isnull(value);
  // @@protoc_insertion_point(field_set:com.gaia.core.Data.isNull)
}

// string hostLanguage = 2;
inline void Data::clear_hostlanguage() {
  _impl_.hostlanguage_.ClearToEmpty();
}
inline const std::string& Data::hostlanguage() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Data.hostLanguage)
  return _internal_hostlanguage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Data::set_hostlanguage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostlanguage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.gaia.core.Data.hostLanguage)
}
inline std::string* Data::mutable_hostlanguage() {
  std::string* _s = _internal_mutable_hostlanguage();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Data.hostLanguage)
  return _s;
}
inline const std::string& Data::_internal_hostlanguage() const {
  return _impl_.hostlanguage_.Get();
}
inline void Data::_internal_set_hostlanguage(const std::string& value) {
  
  _impl_.hostlanguage_.Set(value, GetArenaForAllocation());
}
inline std::string* Data::_internal_mutable_hostlanguage() {
  
  return _impl_.hostlanguage_.Mutable(GetArenaForAllocation());
}
inline std::string* Data::release_hostlanguage() {
  // @@protoc_insertion_point(field_release:com.gaia.core.Data.hostLanguage)
  return _impl_.hostlanguage_.Release();
}
inline void Data::set_allocated_hostlanguage(std::string* hostlanguage) {
  if (hostlanguage != nullptr) {
    
  } else {
    
  }
  _impl_.hostlanguage_.SetAllocated(hostlanguage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostlanguage_.IsDefault()) {
    _impl_.hostlanguage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.Data.hostLanguage)
}

// string type = 3;
inline void Data::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Data::type() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Data.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Data::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.gaia.core.Data.type)
}
inline std::string* Data::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Data.type)
  return _s;
}
inline const std::string& Data::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Data::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Data::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Data::release_type() {
  // @@protoc_insertion_point(field_release:com.gaia.core.Data.type)
  return _impl_.type_.Release();
}
inline void Data::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.Data.type)
}

// bytes data = 4;
inline void Data::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Data::data() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Data.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Data::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.gaia.core.Data.data)
}
inline std::string* Data::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Data.data)
  return _s;
}
inline const std::string& Data::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Data::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Data::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Data::release_data() {
  // @@protoc_insertion_point(field_release:com.gaia.core.Data.data)
  return _impl_.data_.Release();
}
inline void Data::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.Data.data)
}

// -------------------------------------------------------------------

// RepeatedData

// repeated .com.gaia.core.Data datalist = 1;
inline int RepeatedData::_internal_datalist_size() const {
  return _impl_.datalist_.size();
}
inline int RepeatedData::datalist_size() const {
  return _internal_datalist_size();
}
inline void RepeatedData::clear_datalist() {
  _impl_.datalist_.Clear();
}
inline ::com::gaia::core::Data* RepeatedData::mutable_datalist(int index) {
  // @@protoc_insertion_point(field_mutable:com.gaia.core.RepeatedData.datalist)
  return _impl_.datalist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Data >*
RepeatedData::mutable_datalist() {
  // @@protoc_insertion_point(field_mutable_list:com.gaia.core.RepeatedData.datalist)
  return &_impl_.datalist_;
}
inline const ::com::gaia::core::Data& RepeatedData::_internal_datalist(int index) const {
  return _impl_.datalist_.Get(index);
}
inline const ::com::gaia::core::Data& RepeatedData::datalist(int index) const {
  // @@protoc_insertion_point(field_get:com.gaia.core.RepeatedData.datalist)
  return _internal_datalist(index);
}
inline ::com::gaia::core::Data* RepeatedData::_internal_add_datalist() {
  return _impl_.datalist_.Add();
}
inline ::com::gaia::core::Data* RepeatedData::add_datalist() {
  ::com::gaia::core::Data* _add = _internal_add_datalist();
  // @@protoc_insertion_point(field_add:com.gaia.core.RepeatedData.datalist)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::gaia::core::Data >&
RepeatedData::datalist() const {
  // @@protoc_insertion_point(field_list:com.gaia.core.RepeatedData.datalist)
  return _impl_.datalist_;
}

// -------------------------------------------------------------------

// CallRequest

// bool isAsync = 1;
inline void CallRequest::clear_isasync() {
  _impl_.isasync_ = false;
}
inline bool CallRequest::_internal_isasync() const {
  return _impl_.isasync_;
}
inline bool CallRequest::isasync() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.CallRequest.isAsync)
  return _internal_isasync();
}
inline void CallRequest::_internal_set_isasync(bool value) {
  
  _impl_.isasync_ = value;
}
inline void CallRequest::set_isasync(bool value) {
  _internal_set_isasync(value);
  // @@protoc_insertion_point(field_set:com.gaia.core.CallRequest.isAsync)
}

// int64 timeout = 2;
inline void CallRequest::clear_timeout() {
  _impl_.timeout_ = int64_t{0};
}
inline int64_t CallRequest::_internal_timeout() const {
  return _impl_.timeout_;
}
inline int64_t CallRequest::timeout() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.CallRequest.timeout)
  return _internal_timeout();
}
inline void CallRequest::_internal_set_timeout(int64_t value) {
  
  _impl_.timeout_ = value;
}
inline void CallRequest::set_timeout(int64_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:com.gaia.core.CallRequest.timeout)
}

// string command = 3;
inline void CallRequest::clear_command() {
  _impl_.command_.ClearToEmpty();
}
inline const std::string& CallRequest::command() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.CallRequest.command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallRequest::set_command(ArgT0&& arg0, ArgT... args) {
 
 _impl_.command_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.gaia.core.CallRequest.command)
}
inline std::string* CallRequest::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.CallRequest.command)
  return _s;
}
inline const std::string& CallRequest::_internal_command() const {
  return _impl_.command_.Get();
}
inline void CallRequest::_internal_set_command(const std::string& value) {
  
  _impl_.command_.Set(value, GetArenaForAllocation());
}
inline std::string* CallRequest::_internal_mutable_command() {
  
  return _impl_.command_.Mutable(GetArenaForAllocation());
}
inline std::string* CallRequest::release_command() {
  // @@protoc_insertion_point(field_release:com.gaia.core.CallRequest.command)
  return _impl_.command_.Release();
}
inline void CallRequest::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  _impl_.command_.SetAllocated(command, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.command_.IsDefault()) {
    _impl_.command_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.CallRequest.command)
}

// .com.gaia.core.Data param = 4;
inline bool CallRequest::_internal_has_param() const {
  return this != internal_default_instance() && _impl_.param_ != nullptr;
}
inline bool CallRequest::has_param() const {
  return _internal_has_param();
}
inline void CallRequest::clear_param() {
  if (GetArenaForAllocation() == nullptr && _impl_.param_ != nullptr) {
    delete _impl_.param_;
  }
  _impl_.param_ = nullptr;
}
inline const ::com::gaia::core::Data& CallRequest::_internal_param() const {
  const ::com::gaia::core::Data* p = _impl_.param_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::gaia::core::Data&>(
      ::com::gaia::core::_Data_default_instance_);
}
inline const ::com::gaia::core::Data& CallRequest::param() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.CallRequest.param)
  return _internal_param();
}
inline void CallRequest::unsafe_arena_set_allocated_param(
    ::com::gaia::core::Data* param) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  _impl_.param_ = param;
  if (param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.gaia.core.CallRequest.param)
}
inline ::com::gaia::core::Data* CallRequest::release_param() {
  
  ::com::gaia::core::Data* temp = _impl_.param_;
  _impl_.param_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::gaia::core::Data* CallRequest::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_release:com.gaia.core.CallRequest.param)
  
  ::com::gaia::core::Data* temp = _impl_.param_;
  _impl_.param_ = nullptr;
  return temp;
}
inline ::com::gaia::core::Data* CallRequest::_internal_mutable_param() {
  
  if (_impl_.param_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::gaia::core::Data>(GetArenaForAllocation());
    _impl_.param_ = p;
  }
  return _impl_.param_;
}
inline ::com::gaia::core::Data* CallRequest::mutable_param() {
  ::com::gaia::core::Data* _msg = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.CallRequest.param)
  return _msg;
}
inline void CallRequest::set_allocated_param(::com::gaia::core::Data* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.param_;
  }
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(param);
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.param_ = param;
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.CallRequest.param)
}

// -------------------------------------------------------------------

// CallResponse

// .com.gaia.core.ReturnStatus returnStatus = 1;
inline bool CallResponse::_internal_has_returnstatus() const {
  return this != internal_default_instance() && _impl_.returnstatus_ != nullptr;
}
inline bool CallResponse::has_returnstatus() const {
  return _internal_has_returnstatus();
}
inline void CallResponse::clear_returnstatus() {
  if (GetArenaForAllocation() == nullptr && _impl_.returnstatus_ != nullptr) {
    delete _impl_.returnstatus_;
  }
  _impl_.returnstatus_ = nullptr;
}
inline const ::com::gaia::core::ReturnStatus& CallResponse::_internal_returnstatus() const {
  const ::com::gaia::core::ReturnStatus* p = _impl_.returnstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::gaia::core::ReturnStatus&>(
      ::com::gaia::core::_ReturnStatus_default_instance_);
}
inline const ::com::gaia::core::ReturnStatus& CallResponse::returnstatus() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.CallResponse.returnStatus)
  return _internal_returnstatus();
}
inline void CallResponse::unsafe_arena_set_allocated_returnstatus(
    ::com::gaia::core::ReturnStatus* returnstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.returnstatus_);
  }
  _impl_.returnstatus_ = returnstatus;
  if (returnstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.gaia.core.CallResponse.returnStatus)
}
inline ::com::gaia::core::ReturnStatus* CallResponse::release_returnstatus() {
  
  ::com::gaia::core::ReturnStatus* temp = _impl_.returnstatus_;
  _impl_.returnstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::gaia::core::ReturnStatus* CallResponse::unsafe_arena_release_returnstatus() {
  // @@protoc_insertion_point(field_release:com.gaia.core.CallResponse.returnStatus)
  
  ::com::gaia::core::ReturnStatus* temp = _impl_.returnstatus_;
  _impl_.returnstatus_ = nullptr;
  return temp;
}
inline ::com::gaia::core::ReturnStatus* CallResponse::_internal_mutable_returnstatus() {
  
  if (_impl_.returnstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::gaia::core::ReturnStatus>(GetArenaForAllocation());
    _impl_.returnstatus_ = p;
  }
  return _impl_.returnstatus_;
}
inline ::com::gaia::core::ReturnStatus* CallResponse::mutable_returnstatus() {
  ::com::gaia::core::ReturnStatus* _msg = _internal_mutable_returnstatus();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.CallResponse.returnStatus)
  return _msg;
}
inline void CallResponse::set_allocated_returnstatus(::com::gaia::core::ReturnStatus* returnstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.returnstatus_;
  }
  if (returnstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(returnstatus);
    if (message_arena != submessage_arena) {
      returnstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, returnstatus, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.returnstatus_ = returnstatus;
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.CallResponse.returnStatus)
}

// .com.gaia.core.Data result = 2;
inline bool CallResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool CallResponse::has_result() const {
  return _internal_has_result();
}
inline void CallResponse::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::com::gaia::core::Data& CallResponse::_internal_result() const {
  const ::com::gaia::core::Data* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::gaia::core::Data&>(
      ::com::gaia::core::_Data_default_instance_);
}
inline const ::com::gaia::core::Data& CallResponse::result() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.CallResponse.result)
  return _internal_result();
}
inline void CallResponse::unsafe_arena_set_allocated_result(
    ::com::gaia::core::Data* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.gaia.core.CallResponse.result)
}
inline ::com::gaia::core::Data* CallResponse::release_result() {
  
  ::com::gaia::core::Data* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::gaia::core::Data* CallResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:com.gaia.core.CallResponse.result)
  
  ::com::gaia::core::Data* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::com::gaia::core::Data* CallResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::gaia::core::Data>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::com::gaia::core::Data* CallResponse::mutable_result() {
  ::com::gaia::core::Data* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.CallResponse.result)
  return _msg;
}
inline void CallResponse::set_allocated_result(::com::gaia::core::Data* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.CallResponse.result)
}

// -------------------------------------------------------------------

// Job

// string jobId = 1;
inline void Job::clear_jobid() {
  _impl_.jobid_.ClearToEmpty();
}
inline const std::string& Job::jobid() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Job.jobId)
  return _internal_jobid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_jobid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jobid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.gaia.core.Job.jobId)
}
inline std::string* Job::mutable_jobid() {
  std::string* _s = _internal_mutable_jobid();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Job.jobId)
  return _s;
}
inline const std::string& Job::_internal_jobid() const {
  return _impl_.jobid_.Get();
}
inline void Job::_internal_set_jobid(const std::string& value) {
  
  _impl_.jobid_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_jobid() {
  
  return _impl_.jobid_.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_jobid() {
  // @@protoc_insertion_point(field_release:com.gaia.core.Job.jobId)
  return _impl_.jobid_.Release();
}
inline void Job::set_allocated_jobid(std::string* jobid) {
  if (jobid != nullptr) {
    
  } else {
    
  }
  _impl_.jobid_.SetAllocated(jobid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jobid_.IsDefault()) {
    _impl_.jobid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.Job.jobId)
}

// string name = 2;
inline void Job::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Job::name() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Job.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.gaia.core.Job.name)
}
inline std::string* Job::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Job.name)
  return _s;
}
inline const std::string& Job::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Job::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_name() {
  // @@protoc_insertion_point(field_release:com.gaia.core.Job.name)
  return _impl_.name_.Release();
}
inline void Job::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.Job.name)
}

// -------------------------------------------------------------------

// Task

// .com.gaia.core.Job job = 1;
inline bool Task::_internal_has_job() const {
  return this != internal_default_instance() && _impl_.job_ != nullptr;
}
inline bool Task::has_job() const {
  return _internal_has_job();
}
inline void Task::clear_job() {
  if (GetArenaForAllocation() == nullptr && _impl_.job_ != nullptr) {
    delete _impl_.job_;
  }
  _impl_.job_ = nullptr;
}
inline const ::com::gaia::core::Job& Task::_internal_job() const {
  const ::com::gaia::core::Job* p = _impl_.job_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::gaia::core::Job&>(
      ::com::gaia::core::_Job_default_instance_);
}
inline const ::com::gaia::core::Job& Task::job() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Task.job)
  return _internal_job();
}
inline void Task::unsafe_arena_set_allocated_job(
    ::com::gaia::core::Job* job) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_);
  }
  _impl_.job_ = job;
  if (job) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.gaia.core.Task.job)
}
inline ::com::gaia::core::Job* Task::release_job() {
  
  ::com::gaia::core::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::gaia::core::Job* Task::unsafe_arena_release_job() {
  // @@protoc_insertion_point(field_release:com.gaia.core.Task.job)
  
  ::com::gaia::core::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
  return temp;
}
inline ::com::gaia::core::Job* Task::_internal_mutable_job() {
  
  if (_impl_.job_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::gaia::core::Job>(GetArenaForAllocation());
    _impl_.job_ = p;
  }
  return _impl_.job_;
}
inline ::com::gaia::core::Job* Task::mutable_job() {
  ::com::gaia::core::Job* _msg = _internal_mutable_job();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Task.job)
  return _msg;
}
inline void Task::set_allocated_job(::com::gaia::core::Job* job) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_;
  }
  if (job) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job);
    if (message_arena != submessage_arena) {
      job = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.job_ = job;
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.Task.job)
}

// int64 taskId = 2;
inline void Task::clear_taskid() {
  _impl_.taskid_ = int64_t{0};
}
inline int64_t Task::_internal_taskid() const {
  return _impl_.taskid_;
}
inline int64_t Task::taskid() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Task.taskId)
  return _internal_taskid();
}
inline void Task::_internal_set_taskid(int64_t value) {
  
  _impl_.taskid_ = value;
}
inline void Task::set_taskid(int64_t value) {
  _internal_set_taskid(value);
  // @@protoc_insertion_point(field_set:com.gaia.core.Task.taskId)
}

// int64 tableId = 3;
inline void Task::clear_tableid() {
  _impl_.tableid_ = int64_t{0};
}
inline int64_t Task::_internal_tableid() const {
  return _impl_.tableid_;
}
inline int64_t Task::tableid() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Task.tableId)
  return _internal_tableid();
}
inline void Task::_internal_set_tableid(int64_t value) {
  
  _impl_.tableid_ = value;
}
inline void Task::set_tableid(int64_t value) {
  _internal_set_tableid(value);
  // @@protoc_insertion_point(field_set:com.gaia.core.Task.tableId)
}

// -------------------------------------------------------------------

// Result

// .com.gaia.core.Task task = 1;
inline bool Result::_internal_has_task() const {
  return this != internal_default_instance() && _impl_.task_ != nullptr;
}
inline bool Result::has_task() const {
  return _internal_has_task();
}
inline void Result::clear_task() {
  if (GetArenaForAllocation() == nullptr && _impl_.task_ != nullptr) {
    delete _impl_.task_;
  }
  _impl_.task_ = nullptr;
}
inline const ::com::gaia::core::Task& Result::_internal_task() const {
  const ::com::gaia::core::Task* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::gaia::core::Task&>(
      ::com::gaia::core::_Task_default_instance_);
}
inline const ::com::gaia::core::Task& Result::task() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Result.task)
  return _internal_task();
}
inline void Result::unsafe_arena_set_allocated_task(
    ::com::gaia::core::Task* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.gaia.core.Result.task)
}
inline ::com::gaia::core::Task* Result::release_task() {
  
  ::com::gaia::core::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::gaia::core::Task* Result::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:com.gaia.core.Result.task)
  
  ::com::gaia::core::Task* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::com::gaia::core::Task* Result::_internal_mutable_task() {
  
  if (_impl_.task_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::gaia::core::Task>(GetArenaForAllocation());
    _impl_.task_ = p;
  }
  return _impl_.task_;
}
inline ::com::gaia::core::Task* Result::mutable_task() {
  ::com::gaia::core::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.Result.task)
  return _msg;
}
inline void Result::set_allocated_task(::com::gaia::core::Task* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.task_ = task;
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.Result.task)
}

// int64 resultId = 2;
inline void Result::clear_resultid() {
  _impl_.resultid_ = int64_t{0};
}
inline int64_t Result::_internal_resultid() const {
  return _impl_.resultid_;
}
inline int64_t Result::resultid() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.Result.resultId)
  return _internal_resultid();
}
inline void Result::_internal_set_resultid(int64_t value) {
  
  _impl_.resultid_ = value;
}
inline void Result::set_resultid(int64_t value) {
  _internal_set_resultid(value);
  // @@protoc_insertion_point(field_set:com.gaia.core.Result.resultId)
}

// -------------------------------------------------------------------

// ReturnStatus

// int32 code = 1;
inline void ReturnStatus::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t ReturnStatus::_internal_code() const {
  return _impl_.code_;
}
inline int32_t ReturnStatus::code() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.ReturnStatus.code)
  return _internal_code();
}
inline void ReturnStatus::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void ReturnStatus::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:com.gaia.core.ReturnStatus.code)
}

// string message = 2;
inline void ReturnStatus::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ReturnStatus::message() const {
  // @@protoc_insertion_point(field_get:com.gaia.core.ReturnStatus.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReturnStatus::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.gaia.core.ReturnStatus.message)
}
inline std::string* ReturnStatus::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:com.gaia.core.ReturnStatus.message)
  return _s;
}
inline const std::string& ReturnStatus::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ReturnStatus::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ReturnStatus::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ReturnStatus::release_message() {
  // @@protoc_insertion_point(field_release:com.gaia.core.ReturnStatus.message)
  return _impl_.message_.Release();
}
inline void ReturnStatus::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.gaia.core.ReturnStatus.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace gaia
}  // namespace com

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gaia_5fmeta_2eproto
