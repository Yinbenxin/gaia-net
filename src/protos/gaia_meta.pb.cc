// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gaia_meta.proto

#include "gaia_meta.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace com {
namespace gaia {
namespace core {
PROTOBUF_CONSTEXPR Endpoint::Endpoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EndpointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndpointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndpointDefaultTypeInternal() {}
  union {
    Endpoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndpointDefaultTypeInternal _Endpoint_default_instance_;
PROTOBUF_CONSTEXPR Endpoints::Endpoints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.endpoints_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EndpointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndpointsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndpointsDefaultTypeInternal() {}
  union {
    Endpoints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndpointsDefaultTypeInternal _Endpoints_default_instance_;
PROTOBUF_CONSTEXPR Data::Data(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hostlanguage_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.isnull_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataDefaultTypeInternal() {}
  union {
    Data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataDefaultTypeInternal _Data_default_instance_;
PROTOBUF_CONSTEXPR RepeatedData::RepeatedData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.datalist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RepeatedDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepeatedDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepeatedDataDefaultTypeInternal() {}
  union {
    RepeatedData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepeatedDataDefaultTypeInternal _RepeatedData_default_instance_;
PROTOBUF_CONSTEXPR CallRequest::CallRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.command_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.param_)*/nullptr
  , /*decltype(_impl_.timeout_)*/int64_t{0}
  , /*decltype(_impl_.isasync_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CallRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CallRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CallRequestDefaultTypeInternal() {}
  union {
    CallRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CallRequestDefaultTypeInternal _CallRequest_default_instance_;
PROTOBUF_CONSTEXPR CallResponse::CallResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.returnstatus_)*/nullptr
  , /*decltype(_impl_.result_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CallResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CallResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CallResponseDefaultTypeInternal() {}
  union {
    CallResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CallResponseDefaultTypeInternal _CallResponse_default_instance_;
PROTOBUF_CONSTEXPR Job::Job(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.jobid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct JobDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JobDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JobDefaultTypeInternal() {}
  union {
    Job _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JobDefaultTypeInternal _Job_default_instance_;
PROTOBUF_CONSTEXPR Task::Task(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.job_)*/nullptr
  , /*decltype(_impl_.taskid_)*/int64_t{0}
  , /*decltype(_impl_.tableid_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TaskDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TaskDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TaskDefaultTypeInternal() {}
  union {
    Task _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TaskDefaultTypeInternal _Task_default_instance_;
PROTOBUF_CONSTEXPR Result::Result(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.task_)*/nullptr
  , /*decltype(_impl_.resultid_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResultDefaultTypeInternal() {}
  union {
    Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResultDefaultTypeInternal _Result_default_instance_;
PROTOBUF_CONSTEXPR ReturnStatus::ReturnStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReturnStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReturnStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReturnStatusDefaultTypeInternal() {}
  union {
    ReturnStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReturnStatusDefaultTypeInternal _ReturnStatus_default_instance_;
}  // namespace core
}  // namespace gaia
}  // namespace com
static ::_pb::Metadata file_level_metadata_gaia_5fmeta_2eproto[10];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_gaia_5fmeta_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_gaia_5fmeta_2eproto = nullptr;

const uint32_t TableStruct_gaia_5fmeta_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Endpoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Endpoint, _impl_.ip_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Endpoint, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Endpoint, _impl_.hostname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Endpoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Endpoints, _impl_.endpoints_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Data, _impl_.isnull_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Data, _impl_.hostlanguage_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Data, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Data, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::RepeatedData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::RepeatedData, _impl_.datalist_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::CallRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::CallRequest, _impl_.isasync_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::CallRequest, _impl_.timeout_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::CallRequest, _impl_.command_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::CallRequest, _impl_.param_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::CallResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::CallResponse, _impl_.returnstatus_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::CallResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Job, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Job, _impl_.jobid_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Job, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Task, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Task, _impl_.job_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Task, _impl_.taskid_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Task, _impl_.tableid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Result, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Result, _impl_.task_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::Result, _impl_.resultid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::ReturnStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::ReturnStatus, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::com::gaia::core::ReturnStatus, _impl_.message_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::com::gaia::core::Endpoint)},
  { 9, -1, -1, sizeof(::com::gaia::core::Endpoints)},
  { 16, -1, -1, sizeof(::com::gaia::core::Data)},
  { 26, -1, -1, sizeof(::com::gaia::core::RepeatedData)},
  { 33, -1, -1, sizeof(::com::gaia::core::CallRequest)},
  { 43, -1, -1, sizeof(::com::gaia::core::CallResponse)},
  { 51, -1, -1, sizeof(::com::gaia::core::Job)},
  { 59, -1, -1, sizeof(::com::gaia::core::Task)},
  { 68, -1, -1, sizeof(::com::gaia::core::Result)},
  { 76, -1, -1, sizeof(::com::gaia::core::ReturnStatus)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::com::gaia::core::_Endpoint_default_instance_._instance,
  &::com::gaia::core::_Endpoints_default_instance_._instance,
  &::com::gaia::core::_Data_default_instance_._instance,
  &::com::gaia::core::_RepeatedData_default_instance_._instance,
  &::com::gaia::core::_CallRequest_default_instance_._instance,
  &::com::gaia::core::_CallResponse_default_instance_._instance,
  &::com::gaia::core::_Job_default_instance_._instance,
  &::com::gaia::core::_Task_default_instance_._instance,
  &::com::gaia::core::_Result_default_instance_._instance,
  &::com::gaia::core::_ReturnStatus_default_instance_._instance,
};

const char descriptor_table_protodef_gaia_5fmeta_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017gaia_meta.proto\022\rcom.gaia.core\"6\n\010Endp"
  "oint\022\n\n\002ip\030\001 \001(\t\022\014\n\004port\030\002 \001(\005\022\020\n\010hostna"
  "me\030\003 \001(\t\"7\n\tEndpoints\022*\n\tendpoints\030\001 \003(\013"
  "2\027.com.gaia.core.Endpoint\"H\n\004Data\022\016\n\006isN"
  "ull\030\001 \001(\010\022\024\n\014hostLanguage\030\002 \001(\t\022\014\n\004type\030"
  "\003 \001(\t\022\014\n\004data\030\004 \001(\014\"5\n\014RepeatedData\022%\n\010d"
  "atalist\030\001 \003(\0132\023.com.gaia.core.Data\"d\n\013Ca"
  "llRequest\022\017\n\007isAsync\030\001 \001(\010\022\017\n\007timeout\030\002 "
  "\001(\003\022\017\n\007command\030\003 \001(\t\022\"\n\005param\030\004 \001(\0132\023.co"
  "m.gaia.core.Data\"f\n\014CallResponse\0221\n\014retu"
  "rnStatus\030\001 \001(\0132\033.com.gaia.core.ReturnSta"
  "tus\022#\n\006result\030\002 \001(\0132\023.com.gaia.core.Data"
  "\"\"\n\003Job\022\r\n\005jobId\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\"H\n\004"
  "Task\022\037\n\003job\030\001 \001(\0132\022.com.gaia.core.Job\022\016\n"
  "\006taskId\030\002 \001(\003\022\017\n\007tableId\030\003 \001(\003\"=\n\006Result"
  "\022!\n\004task\030\001 \001(\0132\023.com.gaia.core.Task\022\020\n\010r"
  "esultId\030\002 \001(\003\"-\n\014ReturnStatus\022\014\n\004code\030\001 "
  "\001(\005\022\017\n\007message\030\002 \001(\tB\013B\tBasicMetab\006proto"
  "3"
  ;
static ::_pbi::once_flag descriptor_table_gaia_5fmeta_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_gaia_5fmeta_2eproto = {
    false, false, 721, descriptor_table_protodef_gaia_5fmeta_2eproto,
    "gaia_meta.proto",
    &descriptor_table_gaia_5fmeta_2eproto_once, nullptr, 0, 10,
    schemas, file_default_instances, TableStruct_gaia_5fmeta_2eproto::offsets,
    file_level_metadata_gaia_5fmeta_2eproto, file_level_enum_descriptors_gaia_5fmeta_2eproto,
    file_level_service_descriptors_gaia_5fmeta_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_gaia_5fmeta_2eproto_getter() {
  return &descriptor_table_gaia_5fmeta_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_gaia_5fmeta_2eproto(&descriptor_table_gaia_5fmeta_2eproto);
namespace com {
namespace gaia {
namespace core {

// ===================================================================

class Endpoint::_Internal {
 public:
};

Endpoint::Endpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.Endpoint)
}
Endpoint::Endpoint(const Endpoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Endpoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ip().empty()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hostname().empty()) {
    _this->_impl_.hostname_.Set(from._internal_hostname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.Endpoint)
}

inline void Endpoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , decltype(_impl_.hostname_){}
    , decltype(_impl_.port_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Endpoint::~Endpoint() {
  // @@protoc_insertion_point(destructor:com.gaia.core.Endpoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Endpoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
  _impl_.hostname_.Destroy();
}

void Endpoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Endpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.Endpoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ip_.ClearToEmpty();
  _impl_.hostname_.ClearToEmpty();
  _impl_.port_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Endpoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "com.gaia.core.Endpoint.ip"));
        } else
          goto handle_unusual;
        continue;
      // int32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string hostname = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "com.gaia.core.Endpoint.hostname"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Endpoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.Endpoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ip = 1;
  if (!this->_internal_ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ip().data(), static_cast<int>(this->_internal_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "com.gaia.core.Endpoint.ip");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_port(), target);
  }

  // string hostname = 3;
  if (!this->_internal_hostname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hostname().data(), static_cast<int>(this->_internal_hostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "com.gaia.core.Endpoint.hostname");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_hostname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.Endpoint)
  return target;
}

size_t Endpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.Endpoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ip = 1;
  if (!this->_internal_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  // string hostname = 3;
  if (!this->_internal_hostname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());
  }

  // int32 port = 2;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Endpoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Endpoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Endpoint::GetClassData() const { return &_class_data_; }


void Endpoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Endpoint*>(&to_msg);
  auto& from = static_cast<const Endpoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.Endpoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ip().empty()) {
    _this->_internal_set_ip(from._internal_ip());
  }
  if (!from._internal_hostname().empty()) {
    _this->_internal_set_hostname(from._internal_hostname());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Endpoint::CopyFrom(const Endpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.Endpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Endpoint::IsInitialized() const {
  return true;
}

void Endpoint::InternalSwap(Endpoint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostname_, lhs_arena,
      &other->_impl_.hostname_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Endpoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[0]);
}

// ===================================================================

class Endpoints::_Internal {
 public:
};

Endpoints::Endpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.Endpoints)
}
Endpoints::Endpoints(const Endpoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Endpoints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.endpoints_){from._impl_.endpoints_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.Endpoints)
}

inline void Endpoints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.endpoints_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Endpoints::~Endpoints() {
  // @@protoc_insertion_point(destructor:com.gaia.core.Endpoints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Endpoints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.endpoints_.~RepeatedPtrField();
}

void Endpoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Endpoints::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.Endpoints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.endpoints_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Endpoints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .com.gaia.core.Endpoint endpoints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_endpoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Endpoints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.Endpoints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .com.gaia.core.Endpoint endpoints = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_endpoints_size()); i < n; i++) {
    const auto& repfield = this->_internal_endpoints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.Endpoints)
  return target;
}

size_t Endpoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.Endpoints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .com.gaia.core.Endpoint endpoints = 1;
  total_size += 1UL * this->_internal_endpoints_size();
  for (const auto& msg : this->_impl_.endpoints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Endpoints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Endpoints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Endpoints::GetClassData() const { return &_class_data_; }


void Endpoints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Endpoints*>(&to_msg);
  auto& from = static_cast<const Endpoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.Endpoints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.endpoints_.MergeFrom(from._impl_.endpoints_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Endpoints::CopyFrom(const Endpoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.Endpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Endpoints::IsInitialized() const {
  return true;
}

void Endpoints::InternalSwap(Endpoints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.endpoints_.InternalSwap(&other->_impl_.endpoints_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Endpoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[1]);
}

// ===================================================================

class Data::_Internal {
 public:
};

Data::Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.Data)
}
Data::Data(const Data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Data* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hostlanguage_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.isnull_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hostlanguage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostlanguage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hostlanguage().empty()) {
    _this->_impl_.hostlanguage_.Set(from._internal_hostlanguage(), 
      _this->GetArenaForAllocation());
  }
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.isnull_ = from._impl_.isnull_;
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.Data)
}

inline void Data::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hostlanguage_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.data_){}
    , decltype(_impl_.isnull_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.hostlanguage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostlanguage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Data::~Data() {
  // @@protoc_insertion_point(destructor:com.gaia.core.Data)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hostlanguage_.Destroy();
  _impl_.type_.Destroy();
  _impl_.data_.Destroy();
}

void Data::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Data::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.Data)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hostlanguage_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  _impl_.data_.ClearToEmpty();
  _impl_.isnull_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Data::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isNull = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isnull_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string hostLanguage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_hostlanguage();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "com.gaia.core.Data.hostLanguage"));
        } else
          goto handle_unusual;
        continue;
      // string type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "com.gaia.core.Data.type"));
        } else
          goto handle_unusual;
        continue;
      // bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Data::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.Data)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isNull = 1;
  if (this->_internal_isnull() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isnull(), target);
  }

  // string hostLanguage = 2;
  if (!this->_internal_hostlanguage().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hostlanguage().data(), static_cast<int>(this->_internal_hostlanguage().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "com.gaia.core.Data.hostLanguage");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_hostlanguage(), target);
  }

  // string type = 3;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "com.gaia.core.Data.type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_type(), target);
  }

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.Data)
  return target;
}

size_t Data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.Data)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string hostLanguage = 2;
  if (!this->_internal_hostlanguage().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostlanguage());
  }

  // string type = 3;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // bool isNull = 1;
  if (this->_internal_isnull() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Data::GetClassData() const { return &_class_data_; }


void Data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Data*>(&to_msg);
  auto& from = static_cast<const Data&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.Data)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_hostlanguage().empty()) {
    _this->_internal_set_hostlanguage(from._internal_hostlanguage());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  if (from._internal_isnull() != 0) {
    _this->_internal_set_isnull(from._internal_isnull());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Data::CopyFrom(const Data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.Data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Data::IsInitialized() const {
  return true;
}

void Data::InternalSwap(Data* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostlanguage_, lhs_arena,
      &other->_impl_.hostlanguage_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.isnull_, other->_impl_.isnull_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Data::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[2]);
}

// ===================================================================

class RepeatedData::_Internal {
 public:
};

RepeatedData::RepeatedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.RepeatedData)
}
RepeatedData::RepeatedData(const RepeatedData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RepeatedData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.datalist_){from._impl_.datalist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.RepeatedData)
}

inline void RepeatedData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.datalist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RepeatedData::~RepeatedData() {
  // @@protoc_insertion_point(destructor:com.gaia.core.RepeatedData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RepeatedData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.datalist_.~RepeatedPtrField();
}

void RepeatedData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RepeatedData::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.RepeatedData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.datalist_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RepeatedData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .com.gaia.core.Data datalist = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_datalist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RepeatedData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.RepeatedData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .com.gaia.core.Data datalist = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_datalist_size()); i < n; i++) {
    const auto& repfield = this->_internal_datalist(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.RepeatedData)
  return target;
}

size_t RepeatedData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.RepeatedData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .com.gaia.core.Data datalist = 1;
  total_size += 1UL * this->_internal_datalist_size();
  for (const auto& msg : this->_impl_.datalist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RepeatedData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RepeatedData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RepeatedData::GetClassData() const { return &_class_data_; }


void RepeatedData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RepeatedData*>(&to_msg);
  auto& from = static_cast<const RepeatedData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.RepeatedData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.datalist_.MergeFrom(from._impl_.datalist_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RepeatedData::CopyFrom(const RepeatedData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.RepeatedData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepeatedData::IsInitialized() const {
  return true;
}

void RepeatedData::InternalSwap(RepeatedData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.datalist_.InternalSwap(&other->_impl_.datalist_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RepeatedData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[3]);
}

// ===================================================================

class CallRequest::_Internal {
 public:
  static const ::com::gaia::core::Data& param(const CallRequest* msg);
};

const ::com::gaia::core::Data&
CallRequest::_Internal::param(const CallRequest* msg) {
  return *msg->_impl_.param_;
}
CallRequest::CallRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.CallRequest)
}
CallRequest::CallRequest(const CallRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CallRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.command_){}
    , decltype(_impl_.param_){nullptr}
    , decltype(_impl_.timeout_){}
    , decltype(_impl_.isasync_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.command_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_command().empty()) {
    _this->_impl_.command_.Set(from._internal_command(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_param()) {
    _this->_impl_.param_ = new ::com::gaia::core::Data(*from._impl_.param_);
  }
  ::memcpy(&_impl_.timeout_, &from._impl_.timeout_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isasync_) -
    reinterpret_cast<char*>(&_impl_.timeout_)) + sizeof(_impl_.isasync_));
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.CallRequest)
}

inline void CallRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.command_){}
    , decltype(_impl_.param_){nullptr}
    , decltype(_impl_.timeout_){int64_t{0}}
    , decltype(_impl_.isasync_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.command_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CallRequest::~CallRequest() {
  // @@protoc_insertion_point(destructor:com.gaia.core.CallRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CallRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.command_.Destroy();
  if (this != internal_default_instance()) delete _impl_.param_;
}

void CallRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CallRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.CallRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.command_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.param_ != nullptr) {
    delete _impl_.param_;
  }
  _impl_.param_ = nullptr;
  ::memset(&_impl_.timeout_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isasync_) -
      reinterpret_cast<char*>(&_impl_.timeout_)) + sizeof(_impl_.isasync_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CallRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isAsync = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.isasync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 timeout = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string command = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_command();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "com.gaia.core.CallRequest.command"));
        } else
          goto handle_unusual;
        continue;
      // .com.gaia.core.Data param = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_param(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CallRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.CallRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isAsync = 1;
  if (this->_internal_isasync() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isasync(), target);
  }

  // int64 timeout = 2;
  if (this->_internal_timeout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_timeout(), target);
  }

  // string command = 3;
  if (!this->_internal_command().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_command().data(), static_cast<int>(this->_internal_command().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "com.gaia.core.CallRequest.command");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_command(), target);
  }

  // .com.gaia.core.Data param = 4;
  if (this->_internal_has_param()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::param(this),
        _Internal::param(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.CallRequest)
  return target;
}

size_t CallRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.CallRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string command = 3;
  if (!this->_internal_command().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_command());
  }

  // .com.gaia.core.Data param = 4;
  if (this->_internal_has_param()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.param_);
  }

  // int64 timeout = 2;
  if (this->_internal_timeout() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timeout());
  }

  // bool isAsync = 1;
  if (this->_internal_isasync() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CallRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CallRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CallRequest::GetClassData() const { return &_class_data_; }


void CallRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CallRequest*>(&to_msg);
  auto& from = static_cast<const CallRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.CallRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_command().empty()) {
    _this->_internal_set_command(from._internal_command());
  }
  if (from._internal_has_param()) {
    _this->_internal_mutable_param()->::com::gaia::core::Data::MergeFrom(
        from._internal_param());
  }
  if (from._internal_timeout() != 0) {
    _this->_internal_set_timeout(from._internal_timeout());
  }
  if (from._internal_isasync() != 0) {
    _this->_internal_set_isasync(from._internal_isasync());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CallRequest::CopyFrom(const CallRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.CallRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallRequest::IsInitialized() const {
  return true;
}

void CallRequest::InternalSwap(CallRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.command_, lhs_arena,
      &other->_impl_.command_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CallRequest, _impl_.isasync_)
      + sizeof(CallRequest::_impl_.isasync_)
      - PROTOBUF_FIELD_OFFSET(CallRequest, _impl_.param_)>(
          reinterpret_cast<char*>(&_impl_.param_),
          reinterpret_cast<char*>(&other->_impl_.param_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CallRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[4]);
}

// ===================================================================

class CallResponse::_Internal {
 public:
  static const ::com::gaia::core::ReturnStatus& returnstatus(const CallResponse* msg);
  static const ::com::gaia::core::Data& result(const CallResponse* msg);
};

const ::com::gaia::core::ReturnStatus&
CallResponse::_Internal::returnstatus(const CallResponse* msg) {
  return *msg->_impl_.returnstatus_;
}
const ::com::gaia::core::Data&
CallResponse::_Internal::result(const CallResponse* msg) {
  return *msg->_impl_.result_;
}
CallResponse::CallResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.CallResponse)
}
CallResponse::CallResponse(const CallResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CallResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.returnstatus_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_returnstatus()) {
    _this->_impl_.returnstatus_ = new ::com::gaia::core::ReturnStatus(*from._impl_.returnstatus_);
  }
  if (from._internal_has_result()) {
    _this->_impl_.result_ = new ::com::gaia::core::Data(*from._impl_.result_);
  }
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.CallResponse)
}

inline void CallResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.returnstatus_){nullptr}
    , decltype(_impl_.result_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CallResponse::~CallResponse() {
  // @@protoc_insertion_point(destructor:com.gaia.core.CallResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CallResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.returnstatus_;
  if (this != internal_default_instance()) delete _impl_.result_;
}

void CallResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CallResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.CallResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.returnstatus_ != nullptr) {
    delete _impl_.returnstatus_;
  }
  _impl_.returnstatus_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CallResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .com.gaia.core.ReturnStatus returnStatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_returnstatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .com.gaia.core.Data result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CallResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.CallResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .com.gaia.core.ReturnStatus returnStatus = 1;
  if (this->_internal_has_returnstatus()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::returnstatus(this),
        _Internal::returnstatus(this).GetCachedSize(), target, stream);
  }

  // .com.gaia.core.Data result = 2;
  if (this->_internal_has_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.CallResponse)
  return target;
}

size_t CallResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.CallResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .com.gaia.core.ReturnStatus returnStatus = 1;
  if (this->_internal_has_returnstatus()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.returnstatus_);
  }

  // .com.gaia.core.Data result = 2;
  if (this->_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.result_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CallResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CallResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CallResponse::GetClassData() const { return &_class_data_; }


void CallResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CallResponse*>(&to_msg);
  auto& from = static_cast<const CallResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.CallResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_returnstatus()) {
    _this->_internal_mutable_returnstatus()->::com::gaia::core::ReturnStatus::MergeFrom(
        from._internal_returnstatus());
  }
  if (from._internal_has_result()) {
    _this->_internal_mutable_result()->::com::gaia::core::Data::MergeFrom(
        from._internal_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CallResponse::CopyFrom(const CallResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.CallResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallResponse::IsInitialized() const {
  return true;
}

void CallResponse::InternalSwap(CallResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CallResponse, _impl_.result_)
      + sizeof(CallResponse::_impl_.result_)
      - PROTOBUF_FIELD_OFFSET(CallResponse, _impl_.returnstatus_)>(
          reinterpret_cast<char*>(&_impl_.returnstatus_),
          reinterpret_cast<char*>(&other->_impl_.returnstatus_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CallResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[5]);
}

// ===================================================================

class Job::_Internal {
 public:
};

Job::Job(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.Job)
}
Job::Job(const Job& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Job* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.jobid_){}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.jobid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.jobid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_jobid().empty()) {
    _this->_impl_.jobid_.Set(from._internal_jobid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.Job)
}

inline void Job::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.jobid_){}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.jobid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.jobid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Job::~Job() {
  // @@protoc_insertion_point(destructor:com.gaia.core.Job)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Job::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.jobid_.Destroy();
  _impl_.name_.Destroy();
}

void Job::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Job::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.Job)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.jobid_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Job::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string jobId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_jobid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "com.gaia.core.Job.jobId"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "com.gaia.core.Job.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Job::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.Job)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string jobId = 1;
  if (!this->_internal_jobid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_jobid().data(), static_cast<int>(this->_internal_jobid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "com.gaia.core.Job.jobId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_jobid(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "com.gaia.core.Job.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.Job)
  return target;
}

size_t Job::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.Job)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string jobId = 1;
  if (!this->_internal_jobid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_jobid());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Job::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Job::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Job::GetClassData() const { return &_class_data_; }


void Job::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Job*>(&to_msg);
  auto& from = static_cast<const Job&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.Job)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_jobid().empty()) {
    _this->_internal_set_jobid(from._internal_jobid());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Job::CopyFrom(const Job& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.Job)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Job::IsInitialized() const {
  return true;
}

void Job::InternalSwap(Job* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.jobid_, lhs_arena,
      &other->_impl_.jobid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Job::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[6]);
}

// ===================================================================

class Task::_Internal {
 public:
  static const ::com::gaia::core::Job& job(const Task* msg);
};

const ::com::gaia::core::Job&
Task::_Internal::job(const Task* msg) {
  return *msg->_impl_.job_;
}
Task::Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.Task)
}
Task::Task(const Task& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Task* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.job_){nullptr}
    , decltype(_impl_.taskid_){}
    , decltype(_impl_.tableid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_job()) {
    _this->_impl_.job_ = new ::com::gaia::core::Job(*from._impl_.job_);
  }
  ::memcpy(&_impl_.taskid_, &from._impl_.taskid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tableid_) -
    reinterpret_cast<char*>(&_impl_.taskid_)) + sizeof(_impl_.tableid_));
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.Task)
}

inline void Task::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.job_){nullptr}
    , decltype(_impl_.taskid_){int64_t{0}}
    , decltype(_impl_.tableid_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Task::~Task() {
  // @@protoc_insertion_point(destructor:com.gaia.core.Task)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Task::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.job_;
}

void Task::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Task::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.Task)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.job_ != nullptr) {
    delete _impl_.job_;
  }
  _impl_.job_ = nullptr;
  ::memset(&_impl_.taskid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tableid_) -
      reinterpret_cast<char*>(&_impl_.taskid_)) + sizeof(_impl_.tableid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Task::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .com.gaia.core.Job job = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_job(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 taskId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.taskid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 tableId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.tableid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Task::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.Task)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .com.gaia.core.Job job = 1;
  if (this->_internal_has_job()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::job(this),
        _Internal::job(this).GetCachedSize(), target, stream);
  }

  // int64 taskId = 2;
  if (this->_internal_taskid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_taskid(), target);
  }

  // int64 tableId = 3;
  if (this->_internal_tableid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_tableid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.Task)
  return target;
}

size_t Task::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.Task)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .com.gaia.core.Job job = 1;
  if (this->_internal_has_job()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.job_);
  }

  // int64 taskId = 2;
  if (this->_internal_taskid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_taskid());
  }

  // int64 tableId = 3;
  if (this->_internal_tableid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tableid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Task::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Task::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Task::GetClassData() const { return &_class_data_; }


void Task::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Task*>(&to_msg);
  auto& from = static_cast<const Task&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.Task)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_job()) {
    _this->_internal_mutable_job()->::com::gaia::core::Job::MergeFrom(
        from._internal_job());
  }
  if (from._internal_taskid() != 0) {
    _this->_internal_set_taskid(from._internal_taskid());
  }
  if (from._internal_tableid() != 0) {
    _this->_internal_set_tableid(from._internal_tableid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Task::CopyFrom(const Task& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.Task)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Task::IsInitialized() const {
  return true;
}

void Task::InternalSwap(Task* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Task, _impl_.tableid_)
      + sizeof(Task::_impl_.tableid_)
      - PROTOBUF_FIELD_OFFSET(Task, _impl_.job_)>(
          reinterpret_cast<char*>(&_impl_.job_),
          reinterpret_cast<char*>(&other->_impl_.job_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Task::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[7]);
}

// ===================================================================

class Result::_Internal {
 public:
  static const ::com::gaia::core::Task& task(const Result* msg);
};

const ::com::gaia::core::Task&
Result::_Internal::task(const Result* msg) {
  return *msg->_impl_.task_;
}
Result::Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.Result)
}
Result::Result(const Result& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Result* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.task_){nullptr}
    , decltype(_impl_.resultid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_task()) {
    _this->_impl_.task_ = new ::com::gaia::core::Task(*from._impl_.task_);
  }
  _this->_impl_.resultid_ = from._impl_.resultid_;
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.Result)
}

inline void Result::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.task_){nullptr}
    , decltype(_impl_.resultid_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Result::~Result() {
  // @@protoc_insertion_point(destructor:com.gaia.core.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.task_;
}

void Result::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Result::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.task_ != nullptr) {
    delete _impl_.task_;
  }
  _impl_.task_ = nullptr;
  _impl_.resultid_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .com.gaia.core.Task task = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_task(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 resultId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.resultid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .com.gaia.core.Task task = 1;
  if (this->_internal_has_task()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::task(this),
        _Internal::task(this).GetCachedSize(), target, stream);
  }

  // int64 resultId = 2;
  if (this->_internal_resultid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_resultid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.Result)
  return target;
}

size_t Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .com.gaia.core.Task task = 1;
  if (this->_internal_has_task()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.task_);
  }

  // int64 resultId = 2;
  if (this->_internal_resultid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_resultid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Result::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Result::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Result::GetClassData() const { return &_class_data_; }


void Result::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Result*>(&to_msg);
  auto& from = static_cast<const Result&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.Result)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_task()) {
    _this->_internal_mutable_task()->::com::gaia::core::Task::MergeFrom(
        from._internal_task());
  }
  if (from._internal_resultid() != 0) {
    _this->_internal_set_resultid(from._internal_resultid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Result::CopyFrom(const Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Result::IsInitialized() const {
  return true;
}

void Result::InternalSwap(Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Result, _impl_.resultid_)
      + sizeof(Result::_impl_.resultid_)
      - PROTOBUF_FIELD_OFFSET(Result, _impl_.task_)>(
          reinterpret_cast<char*>(&_impl_.task_),
          reinterpret_cast<char*>(&other->_impl_.task_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Result::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[8]);
}

// ===================================================================

class ReturnStatus::_Internal {
 public:
};

ReturnStatus::ReturnStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.gaia.core.ReturnStatus)
}
ReturnStatus::ReturnStatus(const ReturnStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReturnStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.code_ = from._impl_.code_;
  // @@protoc_insertion_point(copy_constructor:com.gaia.core.ReturnStatus)
}

inline void ReturnStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReturnStatus::~ReturnStatus() {
  // @@protoc_insertion_point(destructor:com.gaia.core.ReturnStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReturnStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void ReturnStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReturnStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:com.gaia.core.ReturnStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.code_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReturnStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "com.gaia.core.ReturnStatus.message"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReturnStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.gaia.core.ReturnStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // string message = 2;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "com.gaia.core.ReturnStatus.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.gaia.core.ReturnStatus)
  return target;
}

size_t ReturnStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.gaia.core.ReturnStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 2;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReturnStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReturnStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReturnStatus::GetClassData() const { return &_class_data_; }


void ReturnStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReturnStatus*>(&to_msg);
  auto& from = static_cast<const ReturnStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.gaia.core.ReturnStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReturnStatus::CopyFrom(const ReturnStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.gaia.core.ReturnStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReturnStatus::IsInitialized() const {
  return true;
}

void ReturnStatus::InternalSwap(ReturnStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  swap(_impl_.code_, other->_impl_.code_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReturnStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gaia_5fmeta_2eproto_getter, &descriptor_table_gaia_5fmeta_2eproto_once,
      file_level_metadata_gaia_5fmeta_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace core
}  // namespace gaia
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::com::gaia::core::Endpoint*
Arena::CreateMaybeMessage< ::com::gaia::core::Endpoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::Endpoint >(arena);
}
template<> PROTOBUF_NOINLINE ::com::gaia::core::Endpoints*
Arena::CreateMaybeMessage< ::com::gaia::core::Endpoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::Endpoints >(arena);
}
template<> PROTOBUF_NOINLINE ::com::gaia::core::Data*
Arena::CreateMaybeMessage< ::com::gaia::core::Data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::Data >(arena);
}
template<> PROTOBUF_NOINLINE ::com::gaia::core::RepeatedData*
Arena::CreateMaybeMessage< ::com::gaia::core::RepeatedData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::RepeatedData >(arena);
}
template<> PROTOBUF_NOINLINE ::com::gaia::core::CallRequest*
Arena::CreateMaybeMessage< ::com::gaia::core::CallRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::CallRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::com::gaia::core::CallResponse*
Arena::CreateMaybeMessage< ::com::gaia::core::CallResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::CallResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::com::gaia::core::Job*
Arena::CreateMaybeMessage< ::com::gaia::core::Job >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::Job >(arena);
}
template<> PROTOBUF_NOINLINE ::com::gaia::core::Task*
Arena::CreateMaybeMessage< ::com::gaia::core::Task >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::Task >(arena);
}
template<> PROTOBUF_NOINLINE ::com::gaia::core::Result*
Arena::CreateMaybeMessage< ::com::gaia::core::Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::Result >(arena);
}
template<> PROTOBUF_NOINLINE ::com::gaia::core::ReturnStatus*
Arena::CreateMaybeMessage< ::com::gaia::core::ReturnStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::gaia::core::ReturnStatus >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
